#!/bin/bash

set -e

: "${USE_MEM:=true}"

get_repo_commit_time() {
    TZ=UTC0 git log -1 --format='tformat:%cd' --date='format:%Y-%m-%dT%H:%M:%SZ'
}

reproducible_tar() {
    local args=(
        --sort=name
        --format=posix
        --pax-option='exthdr.name=%d/PaxHeaders/%f'
        --pax-option='delete=atime,delete=ctime'
        --clamp-mtime
        --mtime="$SOURCE_EPOCH"
        --numeric-owner
        --owner=0
        --group=0
        "$@"
    )

    LC_ALL=C tar "${args[@]}"
}

main() {
    url="$1"
    branch="$2"

    if $USE_MEM; then
        TMP=/tmp/mem  # mounted by outer script
    else
        TMP=/tmp
    fi

    clone_args=(
        --depth 1
        "$url"
    )

    if [[ -n $branch ]]; then
        clone_args+=( -b "$branch" )
    fi

    pushd "$TMP"
        git clone "${clone_args[@]}" src
        pushd src
            commit_hash="$(git rev-parse HEAD)"
            SOURCE_EPOCH="$(get_repo_commit_time)"
            export SOURCE_EPOCH
            rm -rf .git

            # set all file timestamps to $SOURCE_EPOCH
            find . -exec touch -md "$SOURCE_EPOCH" '{}' '+'
        popd

        basename="$(basename "$url")"
        basename="${basename%.git}"
        destdir="$basename-$commit_hash"
        mv src "$destdir"

        reproducible_tar -cvf "/out/${destdir}.src.tar" "./$destdir"
        # The end artifact may not be exactly reproducible, but the tarball
        # is. We can revert to simple gzip if reproducibility of the end
        # artifact is really important.
        zstd -19 -T0 --rsyncable --rm "/out/${destdir}.src.tar"
    popd
}

main "$@"
